/* -------------------------------------------------------------------------- *
 *                                   OpenMM                                   *
 * -------------------------------------------------------------------------- *
 * This is part of the OpenMM molecular simulation toolkit originating from   *
 * Simbios, the NIH National Center for Physics-Based Simulation of           *
 * Biological Structures at Stanford, funded under the NIH Roadmap for        *
 * Medical Research, grant U54 GM072970. See https://simtk.org.               *
 *                                                                            *
 * Portions copyright (c) 2012 Stanford University and the Authors.           *
 * Authors: Peter Eastman                                                     *
 * Contributors:                                                              *
 *                                                                            *
 * This program is free software: you can redistribute it and/or modify       *
 * it under the terms of the GNU Lesser General Public License as published   *
 * by the Free Software Foundation, either version 3 of the License, or       *
 * (at your option) any later version.                                        *
 *                                                                            *
 * This program is distributed in the hope that it will be useful,            *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of             *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              *
 * GNU Lesser General Public License for more details.                        *
 *                                                                            *
 * You should have received a copy of the GNU Lesser General Public License   *
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.      *
 * -------------------------------------------------------------------------- */

#include "CudaLTMDKernelSources.h"

using namespace OpenMM;
using namespace std;


const string CudaLTMDKernelSources::NMLupdates = "typedef float Real;\n"
"\n"
"extern \"C\" __global__ void kNMLUpdate1_kernel( int numAtoms, int paddedNumAtoms, float tau, float dt, float kT, float4* posq, float4* posqP, float4* velm, long long* force,\n"
"					float4 *random, /*int randomPosition,*/ int* randomPosition, int totalRandoms ) {\n"
"	// Update the velocity.\n"
"	const Real vscale = exp( -dt / tau );\n"
"	const Real fscale = ( 1.0f - vscale ) * tau;\n"
"	const Real noisescale = sqrt( kT * ( 1 - vscale * vscale ) );\n"
"\n"
"	int rpos = randomPosition[blockIdx.x];\n"
"	//int rpos = randomPosition;\n"
"	for( int atom = threadIdx.x + blockIdx.x * blockDim.x; atom < numAtoms; atom += blockDim.x * gridDim.x ) {\n"
"		const float4 n = random[rpos + atom];\n"
"		const float4 randomNoise = make_float4( n.x * noisescale, n.y * noisescale, n.z * noisescale, n.w * noisescale );\n"
"\n"
"		const Real sqrtInvMass = sqrt( velm[atom].w );\n"
"\n"
"		float4 v = velm[atom];\n"
"		float fx = (float)force[atom] / (float)0x100000000;\n"
"		float fy = (float)force[atom+1*paddedNumAtoms] / (float)0x100000000;\n"
"		float fz = (float)force[atom+2*paddedNumAtoms] / (float)0x100000000;\n"
"\n"
"		v.x = ( vscale * v.x ) + ( fscale * fx * v.w ) + ( randomNoise.x * sqrtInvMass );\n"
"		v.y = ( vscale * v.y ) + ( fscale * fy * v.w ) + ( randomNoise.y * sqrtInvMass );\n"
"		v.z = ( vscale * v.z ) + ( fscale * fz * v.w ) + ( randomNoise.z * sqrtInvMass );\n"
"\n"
"		velm[atom] = v;\n"
"	}\n"
"\n"
"	if( threadIdx.x == 0 ) {\n"
"		rpos += paddedNumAtoms;\n"
"		if( rpos > totalRandoms ) {\n"
"			rpos -= totalRandoms;\n"
"		}\n"
"		randomPosition[blockIdx.x] = rpos;\n"
"		//randomPosition = rpos;\n"
"	}\n"
"}\n"
"\n"
"extern \"C\" __global__ void kNMLUpdate2_kernel( int numAtoms, int numModes, float4 *velm, float4 *modes, float *modeWeights ) {\n"
"	extern __shared__ float dotBuffer[];\n"
"	for( int mode = blockIdx.x; mode < numModes; mode += gridDim.x ) {\n"
"		// Compute the projection of the mass weighted velocity onto one normal mode vector.\n"
"		Real dot = 0.0f;\n"
"\n"
"		for( int atom = threadIdx.x; atom < numAtoms; atom += blockDim.x ) {\n"
"			const int modePos = mode * numAtoms + atom;\n"
"			const Real scale = 1.0f / sqrt( velm[atom].w );\n"
"\n"
"			float4 v = velm[atom];\n"
"			float4 m = modes[modePos];\n"
"\n"
"			dot += scale * ( v.x * m.x + v.y * m.y + v.z * m.z );\n"
"		}\n"
"\n"
"		dotBuffer[threadIdx.x] = dot;\n"
"\n"
"		__syncthreads();\n"
"		if( threadIdx.x == 0 ) {\n"
"			Real sum = 0;\n"
"			for( int i = 0; i < blockDim.x; i++ ) {\n"
"				sum += dotBuffer[i];\n"
"			}\n"
"			modeWeights[mode] = sum;\n"
"		}\n"
"	}\n"
"}\n"
"\n"
"extern \"C\" __global__ void kNMLUpdate3_kernel( int numAtoms, int numModes, float dt, float4 *posq, float4 *velm, float4 *modes,\n"
"					 float *modeWeights, float4 *noiseVal ) {\n"
"	// Load the weights into shared memory.\n"
"	extern __shared__ float weightBuffer[];\n"
"	for( int mode = threadIdx.x; mode < numModes; mode += blockDim.x ) {\n"
"		weightBuffer[mode] = modeWeights[mode];\n"
"	}\n"
"	__syncthreads();\n"
"\n"
"	// Compute the projected velocities and update the atom positions.\n"
"	for( int atom = threadIdx.x + blockIdx.x * blockDim.x; atom < numAtoms; atom += blockDim.x * gridDim.x ) {\n"
"		const Real invMass = velm[atom].w, scale = sqrt( invMass );\n"
"\n"
"		float3 v = make_float3( 0.0f, 0.0f, 0.0f );\n"
"		for( int mode = 0; mode < numModes; mode++ ) {\n"
"			float4 m = modes[mode * numAtoms + atom];\n"
"			float weight = weightBuffer[mode];\n"
"			v.x += m.x * weight;\n"
"			v.y += m.y * weight;\n"
"			v.z += m.z * weight;\n"
"		}\n"
"\n"
"		v.x *= scale;\n"
"		v.y *= scale;\n"
"		v.z *= scale;\n"
"		velm[atom] = make_float4( v.x, v.y, v.z, invMass );\n"
"\n"
"		float4 pos = posq[atom];\n"
"\n"
"		// Add Step\n"
"		pos.x += dt * v.x;\n"
"		pos.y += dt * v.y;\n"
"		pos.z += dt * v.z;\n"
"\n"
"#ifdef FAST_NOISE\n"
"		// Remove Noise\n"
"		pos.x -= noiseVal[atom].x;\n"
"		pos.y -= noiseVal[atom].y;\n"
"		pos.z -= noiseVal[atom].z;\n"
"#endif\n"
"\n"
"		posq[atom] = pos;\n"
"	}\n"
"}\n"
"";

const string CudaLTMDKernelSources::fastnoises = "typedef float Real;\n"
"\n"
//"#ifdef FAST_NOISE\n"
"extern \"C\" __global__ void kFastNoise1_kernel( int numAtoms, int paddedNumAtoms, int numModes, float kT, float4 *noiseVal, float4 *velm, float4 *modes,\n"
" 					float *modeWeights, float4 *random, int *randomPosition, int totalRandoms, float maxEigenvalue, float stepSize ) {\n"
"	extern __shared__ float dotBuffer[];\n"
"	const Real val = stepSize / 0.002;\n"
"	const Real noisescale = sqrt( 2 * kT * 1.0f / maxEigenvalue );\n"
"\n"
"	int rpos = randomPosition[blockIdx.x];\n"
"	for( int mode = blockIdx.x; mode < numModes; mode += gridDim.x ) {\n"
"		Real dot = 0.0f;\n"
"               unsigned int seed=100;\n"
"\n"
"		for( int atom = threadIdx.x; atom < numAtoms; atom += blockDim.x ) {\n"
"			const float4 n = random[rpos + atom];\n"
"                       /*float v1,v2,s;\n"
"                       float arr[4];\n"
"                       int i;\n"
"                       for (i = 0; i < 4; i++) {\n"
"                       do {\n" 
"                          unsigned long a = 16807;\n"
"                          unsigned long m = 2147483647;\n"
"                          unsigned long x = seed;\n"
"                          x = (a*x)%m;\n"
"                          seed = (unsigned int)x;\n"
"                          float rand= ((float)x/m);\n"
"                          v1 = 2.0 * ((float) rand/RAND_MAX) - 1;\n"
"                          v2 = 2.0 * ((float) rand/RAND_MAX) - 1;\n"
"                          s = v1*v1 + v2*v2;\n"
"                       } while ( s >= 1.0 );\n"
"                       if (s == 0.0)\n"
"                           arr[i]=0.0;\n"
"                       else\n"
"			    arr[i]= (v1*sqrt(-2.0 * log(s) / s));\n"
"                       }*/\n"
"                       /*float n1 = curand_normal(state);\n"
"                       float n2 = curand_normal(state);\n"
"                       float n3 = curand_normal(state);\n"
"                       float n4 = curand_normal(state);\n"
"			const float4 n = make_float4(n1, n2, n3, n4);*/\n"
"			const float4 randomNoise = make_float4( n.x * noisescale, n.y * noisescale, n.z * noisescale, n.w * noisescale );\n"
"\n"
"			noiseVal[atom] = randomNoise;\n"
"\n"
"			float4 m = modes[mode * numAtoms + atom];\n"
"			dot += randomNoise.x * m.x + randomNoise.y * m.y + randomNoise.z * m.z;\n"
"		}\n"
"\n"
"		dotBuffer[threadIdx.x] = dot;\n"
"\n"
"		__syncthreads();\n"
"		if( threadIdx.x == 0 ) {\n"
"			Real sum = 0;\n"
"			for( int i = 0; i < blockDim.x; i++ ) {\n"
"				sum += dotBuffer[i];\n"
"			}\n"
"			modeWeights[mode] = sum;\n"
"\n"
"			rpos += paddedNumAtoms;\n"
"			if( rpos > totalRandoms ) {\n"
"				rpos -= totalRandoms;\n"
"			}\n"
"			randomPosition[blockIdx.x] = rpos;\n"
"		}\n"
"	}\n"
"}\n"
"\n"
"extern \"C\" __global__ void kFastNoise2_kernel( int numAtoms, int numModes, float4 *posq, float4 *noiseVal, float4 *velm, float4 *modes, float *modeWeights ) {\n"
"	// Load the weights into shared memory.\n"
"	extern __shared__ float weightBuffer[];\n"
"	for( int mode = threadIdx.x; mode < numModes; mode += blockDim.x ) {\n"
"		weightBuffer[mode] = modeWeights[mode];\n"
"	}\n"
"	__syncthreads();\n"
"\n"
"	// Compute the projected forces and update the atom positions.\n"
"	for( int atom = threadIdx.x + blockIdx.x * blockDim.x; atom < numAtoms; atom += blockDim.x * gridDim.x ) {\n"
"		const Real invMass = velm[atom].w, sqrtInvMass = sqrt( invMass );\n"
"\n"
"		float3 r = make_float3( 0.0f, 0.0f, 0.0f );\n"
"		for( int mode = 0; mode < numModes; mode++ ) {\n"
"			float4 m = modes[mode * numAtoms + atom];\n"
"			float weight = weightBuffer[mode];\n"
"			r.x += m.x * weight;\n"
"			r.y += m.y * weight;\n"
"			r.z += m.z * weight;\n"
"		}\n"
"\n"
"		noiseVal[atom] = make_float4( noiseVal[atom].x - r.x, noiseVal[atom].y - r.y, noiseVal[atom].z - r.z, 0.0f );\n"
"		noiseVal[atom].x *= sqrtInvMass;\n"
"		noiseVal[atom].y *= sqrtInvMass;\n"
"		noiseVal[atom].z *= sqrtInvMass;\n"
"\n"
"		float4 pos = posq[atom];\n"
"		pos.x += noiseVal[atom].x;\n"
"		pos.y += noiseVal[atom].y;\n"
"		pos.z += noiseVal[atom].z;\n"
"		posq[atom] = pos;\n"
"	}\n"
"}\n"
//"#endif\n"
"";

const string CudaLTMDKernelSources::minimizationSteps = "\n"
"extern \"C\" __global__ void kRejectMinimizationStep_kernel( int numAtoms, float4 *posq, float4 *oldPosq ) {\n"
"	for( int atom = threadIdx.x + blockIdx.x * blockDim.x; atom < numAtoms; atom += blockDim.x * gridDim.x ) {\n"
"		posq[atom] = oldPosq[atom];\n"
"	}\n"
"}\n"
"\n"
"extern \"C\" __global__ void kAcceptMinimizationStep_kernel( int numAtoms, float4 *posq, float4 *oldPosq ) {\n"
"	for( int atom = threadIdx.x + blockIdx.x * blockDim.x; atom < numAtoms; atom += blockDim.x * gridDim.x ) {\n"
"		oldPosq[atom] = posq[atom];\n"
"	}\n"
"}\n"
"";

const string CudaLTMDKernelSources::linearMinimizers = "typedef float Real;\n"
"\n"
"extern \"C\" __global__ void kNMLLinearMinimize1_kernel( int numAtoms, int paddedNumAtoms, int numModes, float4 *velm, long long *force, float4 *modes, float *modeWeights ) {\n"
"	extern __shared__ float dotBuffer[];\n"
"	for( int mode = blockIdx.x; mode < numModes; mode += gridDim.x ) {\n"
"		// Compute the projection of the mass weighted force onto one normal mode vector.\n"
"		Real dot = 0.0f;\n"
"		for( int atom = threadIdx.x; atom < numAtoms; atom += blockDim.x ) {\n"
"			const Real scale = sqrt( velm[atom].w );\n"
"			const int modePos = mode * numAtoms + atom;\n"
"\n"
"			float fx = (float)force[atom] / (float)0x100000000;\n"
"			float fy = (float)force[atom+1*paddedNumAtoms] / (float)0x100000000;\n"
"			float fz = (float)force[atom+2*paddedNumAtoms] / (float)0x100000000;\n"
"			float4 m = modes[modePos];\n"
"\n"
"			dot += scale * ( fx * m.x + fy * m.y + fz * m.z );\n"
"		}\n"
"		dotBuffer[threadIdx.x] = dot;\n"
"\n"
"		__syncthreads();\n"
"		if( threadIdx.x == 0 ) {\n"
"			Real sum = 0;\n"
"			for( int i = 0; i < blockDim.x; i++ ) {\n"
"				sum += dotBuffer[i];\n"
"			}\n"
"			modeWeights[mode] = sum;\n"
"		}\n"
"	}\n"
"}\n"
"\n"
"extern \"C\" __global__ void kNMLLinearMinimize2_kernel( int numAtoms, int paddedNumAtoms, int numModes, float invMaxEigen, float4 *posq, float4 *posqP, float4 *velm,\n"
"						 long long *force, float4 *modes, float *modeWeights ) {\n"
"	// Load the weights into shared memory.\n"
"	extern __shared__ float weightBuffer[];\n"
"	for( int mode = threadIdx.x; mode < numModes; mode += blockDim.x ) {\n"
"		weightBuffer[mode] = modeWeights[mode];\n"
"	}\n"
"	__syncthreads();\n"
"\n"
"	// Compute the projected forces and update the atom positions.\n"
"	for( int atom = threadIdx.x + blockIdx.x * blockDim.x; atom < numAtoms; atom += blockDim.x * gridDim.x ) {\n"
"		const Real invMass = velm[atom].w, sqrtInvMass = sqrt( invMass ), factor = invMass * invMaxEigen;\n"
"\n"
"		float3 f = make_float3( 0.0f, 0.0f, 0.0f );\n"
"		for( int mode = 0; mode < numModes; mode++ ) {\n"
"			float4 m = modes[mode * numAtoms + atom];\n"
"			float weight = weightBuffer[mode];\n"
"			f.x += m.x * weight;\n"
"			f.y += m.y * weight;\n"
"			f.z += m.z * weight;\n"
"		}\n"
"\n"
"		f.x *= sqrtInvMass;\n"
"		f.y *= sqrtInvMass;\n"
"		f.z *= sqrtInvMass;\n"
"		posqP[atom] = make_float4( (float)force[atom] / (float)0x100000000 - f.x, (float)force[atom+paddedNumAtoms]/(float) 0x100000000 - f.y, (float) force[atom+2*paddedNumAtoms]/(float) 0x100000000  - f.z, 0.0f );\n"
"\n"
"		float4 pos = posq[atom];\n"
"		pos.x += factor * posqP[atom].x;\n"
"		pos.y += factor * posqP[atom].y;\n"
"		pos.z += factor * posqP[atom].z;\n"
"		posq[atom] = pos;\n"
"	}\n"
"}\n"
"";


const string CudaLTMDKernelSources::quadraticMinimizers = "typedef float Real;\n"
"\n"
"extern \"C\" __global__ void kNMLQuadraticMinimize1_kernel( int numAtoms, int paddedNumAtoms, float4 *posqP, float4 *velm, long long *force, float *blockSlope ) {\n"
"	// Compute the slope along the minimization direction.\n"
"	extern __shared__ float slopeBuffer[];\n"
"\n"
"	Real slope = 0.0f;\n"
"	for( int atom = threadIdx.x + blockIdx.x * blockDim.x; atom < numAtoms; atom += blockDim.x * gridDim.x ) {\n"
"		const Real invMass = velm[atom].w;\n"
"		const float4 xp = posqP[atom];\n"
"			const float fx = (float)force[atom] / (float)0x100000000;\n"
"			const float fy = (float)force[atom+1*paddedNumAtoms] / (float)0x100000000;\n"
"			const float fz = (float)force[atom+2*paddedNumAtoms] / (float)0x100000000;\n"
"\n"
"		slope -= invMass * ( xp.x * fx + xp.y * fy + xp.z * fz );\n"
"	}\n"
"	slopeBuffer[threadIdx.x] = slope;\n"
"	__syncthreads();\n"
"	if( threadIdx.x == 0 ) {\n"
"		for( int i = 1; i <  blockDim.x; i++ ) {\n"
"			slope += slopeBuffer[i];\n"
"		}\n"
"		blockSlope[blockIdx.x] = slope;\n"
"	}\n"
"}\n"
"\n"
"extern \"C\" __global__ void kNMLQuadraticMinimize2_kernel( int numAtoms, float currentPE, float lastPE, float invMaxEigen, float4 *posq, float4 *posqP,\n" 
"						float4 *velm, float *blockSlope, float *lambdaval ) {\n"
"	// Load the block contributions into shared memory.\n"
"	extern __shared__ float slopeBuffer[];\n"
"	for( int block = threadIdx.x; block < gridDim.x; block += blockDim.x ) {\n"
"		slopeBuffer[block] = blockSlope[block];\n"
"	}\n"
"\n"
"	__syncthreads();\n"
"\n"
"	// Compute the scaling coefficient.\n"
"	if( threadIdx.x == 0 ) {\n"
"		Real slope = 0.0f;\n"
"		for( int i = 0; i < gridDim.x; i++ ) {\n"
"			slope += slopeBuffer[i];\n"
"		}\n"
"		Real lambda = invMaxEigen;\n"
"		Real oldLambda = lambda;\n"
"		Real a = ( ( ( lastPE - currentPE ) / oldLambda + slope ) / oldLambda );\n"
"\n"
"		if( a != 0.0f ) {\n"
"			const Real b = slope - 2.0f * a * oldLambda;\n"
"			lambda = -b / ( 2.0f * a );\n"
"		} else {\n"
"			lambda = 0.5f * oldLambda;\n"
"		}\n"
"\n"
"		if( lambda <= 0.0f ) {\n"
"			lambda = 0.5f * oldLambda;\n"
"		}\n"
"\n"
"		slopeBuffer[0] = lambda - oldLambda;\n"
"\n"
"		// Store variables for retrival\n"
"		lambdaval[0] = lambda;\n"
"	}\n"
"\n"
"	__syncthreads();\n"
"\n"
"	// Remove previous position update (-oldLambda) and add new move (lambda).\n"
"	const Real dlambda = slopeBuffer[0];\n"
"	for( int atom = threadIdx.x + blockIdx.x * blockDim.x; atom < numAtoms; atom += blockDim.x * gridDim.x ) {\n"
"		const Real factor = velm[atom].w * dlambda;\n"
"\n"
"		float4 pos = posq[atom];\n"
"		pos.x += factor * posqP[atom].x;\n"
"		pos.y += factor * posqP[atom].y;\n"
"		pos.z += factor * posqP[atom].z;\n"
"		posq[atom] = pos;\n"
"	}\n"
"}\n"
"";

